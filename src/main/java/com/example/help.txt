1.消费者消费消息需要保证幂等性
由于实现了消息可靠性导致消息重发或消息重试造成消费者可能会存在消息被重复消费的情况，这种情况就需要保证消息不被重复消费，
也就是消息保证幂等性。
实现幂等性的方法有很多：借助数据库的乐观锁或悲观锁、借助 redis 的分布式锁、借助 redis 实现 token
机制等等都可以很好的保证消息的幂等性。

2.使用消息队列很难做到 100% 的消息可靠性
项目实际开发中使用 RabbitMQ 实现消息可靠性，实践后的感受是消息队列很难能做到 100% 的消息可靠性，上面的实现方案中 RabbitMQ
提供的机制做到的是尽可能地减小消息丢失的几率。大多数情况下消息丢失都是因为代码出现错误，那么这样无论进行多少次重发都是无法解决
问题的，这样只会增加 CPU 的开销，所以我认为更好的解决办法是通过记录日志的方式等待后续回溯时更好的发现问题并解决问题。对于一些
不是很需要保证百分百可靠性的场景，都可以通过记录日志的方式来保证消息可靠性即可。

我在项目中采用的是消息落库的方式，先将消息落库，而后生产者将消息发送给 MQ，使用数据库记录消息的消费情况，对于重试多次仍然无法消费
成功的消息，后续通过定时任务调度的方式对这些无法消费成功的消息进行补偿。我认为这样可以尽可能地保证消息的可靠性。但是同样这样也带来
了问题就是消息落库需要数据库磁盘IO的开销，增大数据库压力同时降低了性能。

总之，在实现消息的可靠性时，应该根据项目的需求来考虑如何处理。对于消息要求可靠性低的只需要在出错时记录日志方便后续回溯解决出错
问题即可，对于消息可靠性要求高的则可以采用消息落库 ＋ 定时任务的方式尽可能保证百分百的可靠性。

3.问题
Cannot resolve configuration property 'spring.rabbitmq.publisher-confirm-type'
spring.rabbitmq.publisher-confirm在springboot2.2.0.RELEASE版本之前是amqp正式支持的属性，用来配置消息发送到交换器
之后是否触发回调方法，在2.2.0及之后使用spring.rabbitmq.publisher-confirm-type属性配置代替，用来配置更多的确认类型；


4.死信队列
4.1. 死信的概念
先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker
或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，
这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。

应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。
还有比如说: 用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。

4.2. 死信的来源
消息 TTL 过期
队列达到最大长度(队列满了，无法再添加数据到 mq 中)
消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false